/ *! jQuery v1.9.1 | (c) 2005, 2012 jQuery Foundation, Inc. | jquery.org / licencia
/ / @ SourceMappingURL = jquery.min.map
* La función / ((e, t) {var n, r, i = typeof nuevo i, a; (! e) si regresan esto, si ("string" == typeof instanceof n) b.isFunction (esto [i]), este [i] (n [i]):? this.attr (i, n [i]); devolver este} if (a = o.getElementById (i [2 ]), una a.parentNode &&) {if (i == a.id [2]) return r.find (e);! this.length = 1, esto [0] = a} return this.context = o, este . = selector de correo, esta} regreso this.length}, toArray: function () {h.call regreso (this)}, obtener: function (e) {return null == e this.toArray ():? 0> e este [this.length + e ]: se [e]}, pushStack: function (e) {var t = b.merge (this.constructor (), e), el retorno t.prevObject = esto, t.context = this.context, t}, cada uno : función (e, t) {return b.each (este, e, t)}, listo: función (e) {. b.ready.promise retorno () realiza (e), esta}, rebanada: función () {return this.pushStack (h.apply (esto, argumentos))}, primero: function () {return this.eq (0)}, por última vez: function () {return this.eq (-1)}, la ecuación: función (e) {var t = this.length, n = + e + (? 0> e t: 0); this.pushStack regreso (? n> = 0 && t> n [presente [n]]: [])}, Mapa: function (e) {this.pushStack regreso (b.map (this, function (t, n) {return e.call (t, n, t)}))}, final: function () {return e, n, r, i, o, a, s = argumentos [0] | | {}, u = 1, l = arguments.length, c = 1;! de (== typeof s && "booleanas" (c = s, s = argumentos [1] | | {}, u = 2), "objeto" == typeof S | | b.isFunction (s) | | (S = {}), l === && u (s = esto, - u), l> u, u + +) if (null! = (O = argumentos [u])) para (i en s}, b.extend ({noConflict: function (t) {return == null e e + "": "objeto" == typeof e | | "función" == typeof e l [m.call (e)] | |? "objeto": typeof r, pues (en r e); retorno r === T | | y.call (e, r)}, isEmptyObject: función (e) {var t; para (t en e) return 1; return 0! }, error: function (e) {throw error (e)}, ParseHTML: (¡e | | "string" = typeof e) función (e, t, n) {if regreso null; "booleano" == typeof t && (n = t, t = 1!), t = t | | o;! var r = C.exec (e), i = n && []; regreso && e.JSON e.JSON.parse e.JSON.parse (n):? nula === n n: "string" == typeof n && (n = b.trim (n), n && k.test (n.replace ( . S, "@") replace (A, "]") sustituirá (E, ""))) función (? "retorno". + n) (): (b.error ("Invalid JSON:" + n) , t)}, parseXML: function (n) {var r, i, si (n | | "string" = typeof n) return null; try {e.DOMParser (i = new DOMParser, r = i!?. parseFromString (n, "text / xml")): (r = new ActiveXObject ("Microsoft.XMLDOM"), r.async = "false", r.loadXML (n))} catch (o) r = {t} volver r && && r.documentElement r.getElementsByTagName ("ParserError") de longitud | | b.error ("Invalid XML!.: . e.replace (j, "ms-") replace (D, L)}, nodeName: function (e, t) {return e.nodeName && e.nodeName.toLowerCase () === t.toLowerCase ()}, cada uno : function (e, t, n) {var r, i = 0, o = e.length, a = M (e), si (n) {if (a) {for (; o> i, i + +) si (r = t.apply (e [i], n), r ===! 1) romper} else para (i en e) if (r = t.apply (e [i], n), r == ! = 1) romper} else if (a) {for (; o> i, i + +) if (r = T.CALL (e [i], i, e [i])!, r === 1) Salto } else para (i en e) if (r = T.CALL (e [i], i, e [i]), r === 1!) romper, volver e}, equipamiento:! && v v.call ( ?) función "ufeff \ u00a0 \" (e) {return null == e "?": v.call (e)}: función (e) {return null == e "": (e + ""). sustituya (T, "")}, MakeArray:? función (e, t) {var n = t | | []; return null && = e (M (Object (e)) b.merge (n, "cadena" == typeof e [e]: e): d.call (n, e)), n}, inArray: función (e, t, n) {var r: si (t) {if (g) volver g . llamada (t, e, n), para (r = T.Length, n = n 0> n Math.max (0, r + n): n:? 0, r> n, n + +) if (n en t && t [n] === e) return n} return-1}, merge: function (e, n) {var r = n.length, i = e.length, o = 0, y si ("número" = = typeof r) for (; r> o, o + +) e [i + +] = n [o]; más mientras (n [o] == t) e [i + +] = n [o + +];! e.length retorno = i, e}, grep: function (e, t, n) {var r, i = [], o = 0, a = e.length, para r = (n = n;; a> o o + +!) ¡t (e [o], o), n == r && i.push (e [o]);} return i, mapas: función (e, t, n) {var r, i = 0, o = e.length, a = M (e), s = [], si (a) for (; o> i, i + +)! r = t (e [i], i, n), null = r && (s [ s.length] = r); más para (i en e) r = t (e [i], i, n), null = r && (s [s.length] = r);! f.apply regreso ([ ], s)}, orientación: 1, delegación: function (e, n) {var r, i, o, retorno "cadena" == typeof n && (o = e [n], n = e, e = o) , b.isFunction (e)? (r = h.call (argumentos, 2), i = function () {return u = 0, l = e.length, c = null == r; if ("objeto" === b.type (r)) {o = 0;! de (u en r) b.access (e, ! n, u, r [u], 0, a, s)} else if (i! == t && (o = 0, b.isFunction (i) | |! (s = 0), c && (s? (n.call (e, i), n = null): (c = n, n = función (e, t, n) {return c.call (b (e), n)})), n)) for (; l> u, u + +) n (e [u], r, s i: i.call (e [u], u, n (e [u], r))?), el retorno o e?: c n.call (e):? l n (e [0], r): a}, ahora: function () {return (nueva r = 1;! try {r = null && == e.frameElement o.documentElement} catch (i) {} && r r.doScroll && función a () {if {try {r.doScroll ("izquierda")} (b.isReady!) catch (e) {return setTimeout (a, 50)} q (), b.ready ()}} (n.promise)} return (t)}, b.each ("Boolean Número cuerdas función Array Fecha RegExp error de objeto "split. (" "), la función (e, t) {l [" [objeto "+ t +"] "] = t.toLowerCase ()}); función M (e) {var t = e.length, n = b.type (e); b.isWindow retorno (e) 1:01 === && e.nodeType t 0: "array" === N | | "función" == n && (0 ==?!?! = t | | "número" == typeof t && t> 0 && t-1 en la e)} r = b (o); var _ = {}; función F (e) {var t = _ [e] = {}; regreso b.each (e.match (w) | | [], la función (e, n) {! t [n] = 0}), t} b.Callbacks = function (e) {e = "string" == typeof e _ [e] | | F (e):? b.extend ({}, e); var t = u.length; (función de i (t) {b.each (t, la función (t, n) {var esto}, remover: function () {return u && b.each (argumentos, la función (e, t) {var e b.inArray (e, u)> -1:?! (¡u | | u.length)}, vacío: function () {return u = [], esto}, deshabilite: function () {return u ! = l = r = t, esto}, discapacitados: function () {u} regreso, bloqueo: function () {return l = t, r | | p.disable (), esto}, bloqueado: function () { volver l}, fireWith: function (e, t) {return t = t | | [], t =! [e, t.slice t.slice ():? l]!, u | | i l && | |! (n l.push (t): c (t)), esto}, fuego: function () {return p.fireWith (esto, los argumentos), esto}, encendido: function () {return i}}! ; regreso p}, b.extend ({diferido: function (e) {var t = [["resolver", "hacer", b.Callbacks ("una vez que la memoria"), "resuelto"], ["rechazar", "fallar", b.Callbacks ("una vez n}, siempre: function () {return i.done (argumentos) falla (argumentos), esto}, entonces:. function () {var e = argumentos, retornar b.Deferred (function (n) {b.each ( t, la función (t, o) {var a = o [0], s = b.isFunction (e [t]) && e [t]; i [o [1]] (function () {var null = e b.extend (e, r): r}}, i = {}; regreso r.pipe = r.then, b.each (t, la función (e, o) {var? I | | o.resolveWith (l, n), o.promise ()}}), b.support = function () {var t, n, r, a, s, u, l, c, p, f, d = o.createElement ("div"); if (d.setAttribute ("className", "t"), d.innerHTML = "<link/> <table> </ table> <a href =" / a " > a </ a> <de entrada in {presentar: 0, cambie: 0, focusin: 0!}) d.setAttribute (c = "en" + f, "t"), t [f + "Bubbles"] = c en e | | d. atributos [c] expando ===; 1.! devolución O = / (: \ {[\ s \ S] * \} | \ [[\ s \ S] * \]) $ /, B = / ([AZ]) / g, función P (e, n , r, i) {if (b.acceptData (e)) {var o, a, s = b.expando, u = "string" == typeof n, l = e.nodeType, p = l? b.cache : e, f = l e [s]: e [s] && s; if (.!! f && p [f] && (i | | P [f] de datos) | | u | | r == t) return f | | (l e [s] = f = c.pop () | | b.guid + +: f = s), p [f] | | (p [f] = {}, l | | (p [f ] toJSON = b.noop)), ("objeto" == typeof n |. | "función" == typeof R (e, t, n) {if (b.acceptData (e)) {var ¿o en t = [t]: (t = b.camelCase (t), t = t en o [t]: t.split ("")), para (r = 0, i = T.Length; i> r, r + +) Borrar o [t [r]], si: retorno} (n (o)) | | (delete s [u] de datos, $ (s [((n $ b.isEmptyObject?). u]))) && (un b.cleanData ([e], 0):?!? b.support.deleteExpando | | s = s.window eliminar e = e.nodeType b.cache [e [b.expando]]: ¡¡e [b.expando] && $ e (e)}, datos: función (e, t, n) {return P (e , t, n)}, REMOVEDATA: función (e, t) {return R (e, t)}, _data: función (e, t, n) {return P (e, t, n, 0)},! _removeData: function (e, t) {return R (e, t, 0!)}, acceptData: function (e) {if return (&& e.nodeType == 1 && e.nodeType 9 == e.nodeType!) 1;! var s} return "objeto" == typeof e this.each (function () {b.data (esto, e)}):? b.access (this, function (n) {return this.each (function () {b.removeData (esto, e)})}}); función W (e, n, r) {if (r === t && 1 === e.nodeType) {var i = . "datos" + n.replace (B, "- $ 1") toLowerCase (); if (r = e.getAttribute (i), "cadena" == typeof r = t} return r} la función $ (e) {var t; para (t en i; vuelva O.Stop, i.call (e, a, o)), r && O && o.empty.fire ()}, _queueHooks: función (e, t) {var n = t + "queueHooks"; retorno b._data (e,! n) | | b._data (e, n, {empty: b.Callbacks ("una vez r = 2; retorno "cadena" = typeof e && (n = E, E = "FX", r -), r> arguments.length b.queue (esta [0], e):? n === t esto:? this.each (function () {var this.each (function () {b.dequeue (esto, e)})}, delay: function (e, t) {return e = b.fx b.fx.speeds [e] | | e: e, t = t | | "fx", this.queue (t, la función (t, n) {var r = setTimeout (t, e); n.stop = function () {clearTimeout (r)}})}, clearQueue : function (e) {return this.queue (e | | "fx", [])}, la promesa: function (e, n) {var r, i = 1, o = b.Deferred (), a = esta , s = this.length, u = function () {- I | | o.resolveWith (a, [a])}, "cadena" = typeof u (), o.promise (n)}}); var b.access (esto, b.attr, e, t, arguments.length> 1)}, removeAttr: function (e) {return this.each (function () {b.removeAttr (esto, e)})}, prop: function (e, t) {b.access regreso (esto, b.prop, e, t, arguments.length> 1)}, removeProp: function (e) {return e = b.propFix [e] | | e, this.each (function () {try {este [e] = t, Suprimir esta [e]} catch (n) {}})}, addClass: function (e) {var t, n, r, i , o, a = 0, s = this.length, u = "string" == typeof e && e; if (b.isFunction (e)) return . "N.className + +" ") Replace (X," "):" ")) {o = 0, mientras que (i = t [o + +])> 0 r.indexOf (" "+ i +" ") && ( r = + i + ""); n.className = b.trim (r)}} devuelva este, removeClass: function (e) {var t, n, r, i, o, a = 0, s = this.length, u = 0 === arguments.length | | "cadena" == typeof e && e; if (b.isFunction (e)) return . "N.className + +" ") replace (X," "):" ")) {o = 0, mientras que (i = t [o + +]) while (r.indexOf (" "+ i +" ")> = 0) r = r.replace ("" + i + "", ""); n.className = e b.trim (r): ""}} devuelva este, toggleClass: function (e, t) {var n = typeof e, r = "booleano" == typeof t; regreso t = "" + e + "", n = 0, r = this.length; for (; r> n, n + +).. if (1 === esta [n] && nodeType ("" + esta [n] className + "") indexOf (t)> = 0) return 0;} return 1, val ") sustituirá (X,.":.! función (e) {var n, r, i, o = esta [0]; {if (arguments.length) devuelven i = b.isFunction (e), this.each (function (n) {var o, a = b (this); 1 === && this.nodeType (o = i e?. llamar (este, n, a.val ()): e, null == o o = "?": "number" == typeof o o + = "": (o) && b.isArray (o = b. mapa (o, función (e) {? return null == e "": e + ""})), r = b.valHooks [this.type] | | b.valHooks [this.nodeName.toLowerCase ()], && r "set" en r && r.set (esto, o, "valor") == T | | (this.value = o))});! si es una declaración (o) r = b.valHooks [o.type] | ? | b.valHooks [o.nodeName.toLowerCase ()], r && "get" en && r (n = r.get (o, "valor")) == t n: (n = o.value, "string "== typeof n n.replace (U," "): null == n" ": n)}}}), b.extend ({valHooks: {opción: {get: function (e) {var ? t = e.attributes.value; retorno T | | t.specified e.value: e.text}}, seleccione: {get: function (e) {var t; a.push (t)} devuelve a}, set: function (e, t) {var n = b.makeArray (t), el retorno o, a, s, u = e.nodeType; if (e && 3 == u && 8 == 2 == u && u!) retorno typeof o == null && (s = o.get (e, n)) s:? (typeof e.getAttribute == i && (s = e.getAttribute (n)), NULL == s t:? s): null ! == r? o && a && "set" en n = e.value; vuelva i, o, a, s = e.nodeType; if (e && 3 == && s 8 s && == 2 == s!) regreso a = 1 == s | | b.isXMLDoc (e), a && (n =! b.propFix [n] | |?? n, o = b.propHooks [n]), r == P ARA && "ajuste" en O && (i = o.set (e, r, n)) == t ¿i: e [n] = r: o && "get" en o == null && (i = o.get (e, n)) i: ¿e [n]}, propHooks: {tabIndex: {get: function ( e) {var n = e.getAttributeNode ("tabindex"), el retorno r =? b.prop (e, n), i = "booleanas" == typeof r && e.getAttribute (n), o = "booleano" == typeof r && K Q null = i:! G.test (n)? e [b.camelCase ("default-" + n)]: i: e.getAttributeNode (n), de retorno o && o.value == 1 n.toLowerCase (): ¡¡¡¿t}, set: function (e , t, n) {return r = e.getAttributeNode (n); b.nodeName regreso (e, "entrada") e.defaultValue: r && r.specified r.value: t}, set: function (e, n, r) {return? r = e.getAttributeNode (n); && r retorno ("id" === n | | "name" === n | | "coords" === n "" == r.value: r.specified! ) r.value: t}, conjunto: la función (e, n, r) {var i = e.getAttributeNode (r), el retorno r = e.getAttribute (n, 2); return null == r t: r}})}), b.each (["href", "src"], la función (e, t) {b.propHooks [t] = {get: function (e) {e.getAttribute regreso (t, 4)}}})), b.support.style | | (b.attrHooks.style = {get: function (e) {return e.style.cssText | | t}, set: function (e, t) {return t = e.parentNode; volver ? b.isArray (n) = e.checked b.inArray (b (e) val (), n.)> = 0: t}})}); var que () {return 0!} ot función () {return 1!} = {b.event mundial: {}, add: function (e, n, r, o, a) {var typeof c [d])} else para (d en c) b.event.remove (e, d + t [l], n, r, 0);! (c) && b.isEmptyObject (delete m.handle, b . _removeData (e, "eventos"))}}, gatillo: function (n, r, i, a) {var b.Event (g, "objeto" == typeof n.result}}, despacho: función (e) {e = b.event.fix (e); var c.postDispatch && c.postDispatch.call (esto, e), e.result}}, manipuladores: function (e, n) {var n.length> u && s.push ({elem: esto, los manipuladores: n.slice (u)}), S}, arreglo: function (e) {if (e [b.expando]) return e; var b.Event (a), t = r.length, mientras que (t -) n = r [t], e [n] = a [n]; regreso burbujas cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey vista timeStamp objetivo que "("), fixHooks dividida. ": {}, keyHooks: {props:" charCode keyCode clave char "split (" "), filtro:. función (e, t ) {return == null && e.which (e.which = null = t.charCode t.charCode:? t.keyCode), e}}, mouseHooks: {props: "buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement. "split (" "), el filtro: function (e, n) {var r, i, a, s = n.button, u = n.fromElement; regreso this.focus (), 1} catch (e) {}}, DelegateType: "focusin"}, desenfoque: {gatillo: function () {return i = b.extend (nueva r = "on" + t; && e.detachEvent (typeof e [r] === i && (e [r] = null), e.detachEvent (r, n))}, b.Event = function (e, n ) {return este instanceof n, r = esto, i = e.relatedTarget, o = e.handleObj;
b.nodeName (this, "forma") 1:! (b.event.add (this, "click._submit keypress._submit", función (e) {var n = e.target; regreso a, s, y si ("objeto" == typeof e) {"cadena" = typeof n && (r = R | | n, n = t);! para (una en e) this.on (a, n, r , e [a], o), devuelva este} if (NULL == r == null && i (i = n, r = n = t?):? == null && i ("string" == typeof n (i = r, r = t): (i = r, r = n, n = t)), i === 1) i = ot; else if (i) Retorno Este, y devuelve 1 === o && (s! = i, i = function (e) {return this.on (e, t, n, r, 1)}, off: function (e, n, r) {var i, o, si regreso (e && e.preventDefault && e.handleObj) e) {for (o por correo) this.off (o, n, e [o]);} devolver esta! return (n === 1 | | "función" == typeof this.on (e, null, t, n)}, unbind: function (e, t) {this.off regreso (e, null, t)}, delegado: function (e, t, n, r) {return this.on (t, e, n, r)}, undelegate: function (e, t, n) {return 1 === arguments.length this.off (e, "**"):? this.off ( t, e | | "**", n)}, gatillo: function (e, t) {return this.each (function () {b.event.trigger (e, t, this)})}, triggerHandler: función (e, n) {var r = esta [0]; r retorno b.event.trigger (e, n, r, 0!): t?}}), la función (e, t) {var n, r , i, o, a, s, u, l, c, p, f, d, h, g, m, y, v, x = "chisporroteo" + nuevo Fecha, w = e.document, T = { }, N = 0, C = 0, k = es (), que E = (), S = que (), A = typeof t, J = 1 << 31, D = [], L = D.pop , H = D.push, q = D.slice, M = D.indexOf | | función (e) {var t = 0, n = this.length; for (; n> t, t + +) if (esto [t ] === e) retorno n = "0 x" + t-65 536, el retorno t, n = [], mientras que (t = esta [e + +]) n.push (t); regreso n}} función RT (e) {return Y.test (e + "")} que funcionar () {var correo , t = []; retorno e = function (n, r) {return t.push (n + = "")> && i.cacheLength borrar e [t.shift ()], e [n] = r}} función ot ( e) {return e [x] = 0, e!} función al (e) {var t = p.createElement ("div"); try {volver e (t)} catch (n) {return 1} finally! {t = null}} FUNCIÓN st (e, t, n, r) {var i, o, a, s, u, l, f, g, m, v,? if ((t t.ownerDocument | | t : ¡¡¡w) == p && c (t), t = t | | P, n = n | | [], e | | "string" = typeof e) retorno n; if (o.id === a) retorno n.push (o), n} else if (&& t.ownerDocument (o = t.ownerDocument.getElementById (a)) && y && (t, o) o.id = == a) retorno n.push (o), n} else {if (i [2]) return ", U = l.length, mientras que (u -) l [u] = g + dt (l [u]); m = && V.test (e) t.parentNode | | t, v = l.join ( ",")} if (v) try {return H.apply (n, q.call (m.querySelectorAll (v), 0)), n} catch (b) {} finally {f | | t.removeAttribute ( "id")}}} return peso (e.replace (W, "$ 1"), t, n, r)} a = st.isXML = function (e) {var t = e && (e.ownerDocument | | E .?) documentElement; retorno t "HTML" == t.nodeName: 1}, c = st.setDocument = function (e) {var n = e e.ownerDocument | | E:? w; regreso t = typeof e.innerHTML = "<div class='hidden e'> </ div> <div name = '"+ x +" "> </ a> <div name='"+x+"'> </ div>", f.insertBefore (e, f.firstChild); var t = n.getElementsByName && n.getElementsByName ( x) Longitud === 2 + n.getElementsByName (x 0) longitud;.. T.getIdNotName retorno = n.getElementById (x), f.removeChild (e), t}), i.attrHandle = a (! función (e) {return e.innerHTML = "<a href='#'> </ a>", e.firstChild && typeof e.firstChild.getAttribute! == A && "#" === e.firstChild.getAttribute (" href ")}) {}: {href: function (e) {e.getAttribute retorno (" href ", 2)}, tipo: function (e) {e.getAttribute retorno (" tipo ")}}, T . getIdNotName (i.find.ID = function (e, t) {if (typeof t.getElementById == A && d) {var n = t.getElementById (e); regreso n && n.parentNode [n]?!?: []}}, i.filter.ID = function (e) {var t = e.replace (ET, TT), función de retorno (e) {e.getAttribute retorno ("id") === t}}) : (i.find.ID = function (e, n) {if (typeof n.getElementById == A && d) {var r = n.getElementById (e); r retorno r.id === e | ¡? | typeof r.getAttributeNode == Un valor && r.getAttributeNode ("id") === e [r]: t: []}}, i.filter.ID = function (e) {var t = e!.?. replace (et, tt), función de retorno (e) {var n = typeof e.getAttributeNode == A && e.getAttributeNode ("id");! regreso n && n.value === t}}), i.find.TAG = T.tagNameNoComments función (e, n) {return typeof n.getElementsByTagName == A n.getElementsByTagName (e):? t}:? función (e, t) {var n, r = [], i = 0, o = t.getElementsByTagName (e); if ("*" === e) {while (n = o [i + +]) 1 === && n.nodeType r.push (n), el retorno r} return o}, i . find.NAME = function && T.getByName (e, n) {return typeof typeof type = "hidden" n = 9 === e.nodeType e.documentElement: e, r = t && t.parentNode; regreso r, el retorno r, i = 0, o = e.parentNode, a = t.parentNode, s = [e] l = [t];! if (e === t) return u = 0,0; if (O! ? | | a) la devolución e === N -1: t === n 1: o -1: a 1:00, si (o === a) la devolución?? n = m.call (e, t); if (! n | | T.disconnectedMatch | | && e.document 11 == e.document.nodeType) return n} catch (r) {} return Error ("error de sintaxis, de expresión reconocido:" + e)}, st.uniqueSort = function (e) {var e}; función ut (e, t) {var n = t && e, r = n && (~ t.sourceIndex | | j) - (~ e.sourceIndex | | j); if (r) devuelven r; if (n) while (n = n.nextSibling) if (n === t) return -1; retorno e 1: -1} función lt (e) {function regreso (t) {var n = t.nodeName.toLowerCase () ; retorno "de entrada" === n && Ttipo === e}} función ct (e) {function regreso (t) {var n = t.nodeName.toLowerCase () return ("input" === n | | "botón" === n) && Ttipo === e}} función pt (e) {return ot (function (t) {return t = + t, ot (function (n, r) {var t, n = "", r = 0, i = e.nodeType, si (i) {if (1 === i | | 9 === I | | 11 === i) {if ("string" == typeof e.textContent) e.textContent regreso, porque (e = e.firstChild, e, e = e.nextSibling) n + = o (e)} else if (3 === I | | 4 === i ) volver e.nodeValue} else for (; t = e [r], r + +) + n = o (t), el retorno e [1] = e [1] reemplazará (ET, TT), e [3] = ".. replace (ET, TT), (e [4] | | | e [5] |") "~ =" === e [2] && (e [3] = "" + e [3] + ""), e.slice (0,4)}, NIÑO: function (e) {return t, n = E [5] && e [2];! devolución t.nodeName && t.nodeName.toLowerCase () === e})}, CLASE: function (e) {var t = k [e + ""]; retorno T | | (t = RegExp ("(^ |" + _ + ")" + e + "(" + _ + "| $)")) && (k e, función (e) {return t.test (e.className | | | e.getAttribute typeof == A e.getAttribute && (" class ") | |" ")})}, ATTR: function (e, t, n) {function retorno (r) {var i = st.attr (r, e), el retorno "+ I +" o = "enésimo" == e.slice (0,3), a = "último" == e.slice (-4), s = "del tipo" === t;! return 1 === && r 0 === i función (e) {return e.parentNode!}: función (t, n, u) {var si (v && (l = (t [x] | | (t [x] = {})) [e]) && l [0] === N) f = l [1]; más f-= i, f === r | | 0 === f% r && f / r> = 0}}}, PSEUDO: function (e, t) {var n, r = i.pseudos [e] | | i.setFilters [e.toLowerCase ()] | | st.error ("pseudo compatibles:" + e); retorno r [x] r (t):? r.length> 1 (n = [e, e, "", t], i.setFilters.hasOwnProperty (e.toLowerCase ()) ot (function (e, n) {var i, o = r (e, t), a = o.length;? while (a- -) i = M.call (e, o [a]), e [i] = (n [i] = o [a])}): function (e) {return r (e, 0, n)! }): r}}, pseudos: {No: ot (function (e) {var t = [], n = [], r = s (e.replace (W, "$ 1")); retorno r [x ] ot (function (e, t, n, i) {var o, a = r (e, null, i, []), s = e.length;? while (s -) (o = a [s ]) && (e [s] = (t [s] = o!))}): function (e, i, o) {return t [0] = e, r (t, nulo, o, n), ! n.pop ()}}), dispone:. ot (function (e) {function regreso (t) {return st (e, t) de longitud> 0}}), contiene: ot (function (e) {return función (t) {return (t.textContent | | t.innerText | | o (t)) indexOf (e)> -1.}}), lang: ot (function (e) {return X.test (e | | "") | | st.error ("sin apoyo lang:.?" + e), e = e.replace (et, tt) toLowerCase (), la función (t) {var n; hacer si (n = d t . getAttribute ("xml: lang") | | t.getAttribute ("lang"): t.lang) return n = e.location && e.location.hash; regreso n && n.slice (1) === t.id}, raíz: function (e) {return e === f}, foco: function (e) {return e.disabled === 1}, los discapacitados: la función (e) {return e.disabled === 0}, comprobado: la función (e) {var Q.test (e.nodeName)}, de entrada: function (e) {return G.test (e.nodeName)}, un botón: function (e) {var t = e.nodeName.toLowerCase (); return "entrada" === t && "botón" === e.type | | "botón" === t}, texto: function (e) {var n = 0; for (; t> n, n + = 2) e.push (n), el retorno e}), impar: pt (function (e, t) {var n = 1; for (; t> n; + n = 2) e.push (n), e vuelta}), lt: pt (function (e, t, n) {var r = 0> n n + t: n; for (; - r> = 0 ;) e.push (r), el retorno e}), gt: pt (function (e, t, n) {var r = 0> n n + t: n; for (; t> + + r; ) e.push (r), el retorno e})}}, pues (n in {radio: ¡¡¡¡¡0, casilla: 0, file: 0, password: 0, image: 0}) i.pseudos [ n] = lt (n), para (n in {submit: 0, reset: 0}) i.pseudos [n] = ct (n), función ft (e, t) {var n, r, o , a, s, u, l, c = E [e + ""]; if (c) volver ")}), S = s.slice (n.length)), porque (a en la 't s.length: s st.error (e): E (e, u) slice (0)} la función dt (e) {var t = 0, n = e.length, r = "", porque?. (; n> t, t + +) r + = e [e] valor,. retorno r} la función ht (e, t, n) {var i = t.dir, o = n && "parentNode" === i, a = C + +; t.first retorno de la función (t, n, r) {while (t = t [i]) if (1 === t.nodeType | | o) vuelta de correo (t, n, r)}: la función (t, n, s) {var u, l, c, p = N + "" + a; if (s) {while (t = t [i]) if ((1 === t.nodeType | | o ) && e (t, n, s)) return 0} else u === 0} else if (l = c [i] = [p] l [1] = e (t, n, s) | | | r, l [1] === 0) cambio! 0}} función gt (e) {e.length retorno> 1 función (t, n, r) {var i = e.length, mientras que (i -) if (e [i] (t, n,?! r)) return 1; return 0}: ¡e [0]} función mt (e, t, n, r, i) {var a} la función yt (e, t, n, r, i, o) {return && r! r [x] && (r = yt (r)), i &&! i [x] && (i = yt (i, o )), ot (function (o, a, s, u) {var y = mt (y === una y.splice (h, y.length): y)?, i i (null, a, y, u): H.apply (a, y)})} la función vt (e) {var t, n, r, o = e.length, a = i.relative [e [0] tipo.], s = a | | i.relative [""], u = a 1?: 0, c = ht (función (e) {return correo === t}, s, 0), la función p = ht ((e) {return GT (f)} la función bt (e, t) {var n = 0, o = T.Length> 0, a = e.length> 0, s = función (s, u, c, f, d) {var w && (N = k, l = T), x}; retorno o OT (s):? s} = s st.compile = función (e, t) {var n, r = [], i = [], o = S [e + " o}; función xt (e, t, n) {var r = 0, i = T.Length; for (; i> r, r + +) st (e, t [r], n); regreso n} la función peso (e, t, n, r) {var H.apply (n, q.call (r, 0)), N; break}}} regreso s (e, p) (r, t, d, n, V.test (e)), n} i. pseudos.nth = i.pseudos.eq; Tt función () {} i.filters = Tt.prototype = i.pseudos, i.setFilters = new t, n, r, i = this.length; if (! "string" = typeof e) retorno n = this.pushStack (i> 1 b.unique (n):? n), n.selector = (this.selector this.selector + "?": "") + e, n}, tiene: función (e) {var t, n = b (e, este), r = n.length; this.filter regreso (function () {for (t = 0, r> t, t + +) if (b.contains (este, n [ t])) return 0})}, no: función (e) {this.pushStack regreso (ft (esto, e, 1))}, el filtro: función (e) {this.pushStack regreso (ft (esto !, e, 0))}, es: ¡función (e) {return && e ("string" == typeof n, r = 0, i = this.length, o = [], a = lt.test (e) | | "string" = typeof this.pushStack (o.length> 1 b.unique (o): o)}, índice: función (e) {return e "cadena" == typeof n = "string" == typeof e b (e, t): b.makeArray (e && e.nodeType [e]: e?), r = b.merge (this.get (), n) devuelve esto?. pushStack (b.unique (r))}, addBack: función (e) {return this.add (null == e this.prevObject:? this.prevObject.filter (e))}}), b.fn.andSelf = b.fn.addBack, función pt (e, t) {hacer e = e [t], mientras que (== 1 && e e.nodeType!), e vuelta} b.each ({parent: function (e) {var t = e.parentNode; vuelva t && 11 == t.nodeType t:? null}, los padres: function (e) {return b.dir (e, "parentNode")}, parentsUntil: function (e, t, n) {return b.dir (e, "parentNode", n)}, al lado: function (e) {return pt (e, "nextSibling")}, prev: function (e) {return pt (e, "previousSibling") }, nextAll: function (e) {return b.dir (e, "nextSibling")}, prevAll: function (e) {return b.dir (e, "previousSibling")}, nextUntil: function (e, t, n) {return b.dir (e, "nextSibling", n)}, prevUntil: function (e, t, n) {return b.dir (e, "previousSibling", n)}, hermanos: function (e) {return b.sibling ((e.parentNode | | {}) firstChild, e.)}, los niños: function (e) {b.sibling regreso (e.firstChild)}, el contenido: function (e) {return i = b.map (esto, t, n); regreso at.test (e) | | (r = n), && r "cadena" == typeof i}, hermano: la función (e, t) {var n = []; for (; e; e = e.nextSibling) 1 === e.nodeType && e == t && n.push (e); regreso n}} ), función ft (e, t, n) {if (t = t | | 0, b.isFunction (t)) return b.grep (e, la función (e, r) {var i = T.CALL! (e, r, e), i volver === n}); if (t.nodeType) return b.grep (e, función (e) {return e === t === n}); if ( "cadena" == typeof t) {var r = b.grep (e, función (e) {return 1 === e.nodeType}); if (ut.test (t)) return b.filter (t, r, n);! t = b.filter (t, r)} regreso b.grep (e, la función (e) {return b.inArray (e, t)> = 0 === n})} la función dt (e) {var n} var b.access (this, function (e) {return this.each (función de (t) {b (este) wrapAll (e.call (este, t)).}); si (esta [0]) {var e = este, mientras que (&& e.firstChild 1 === e.firstChild.nodeType) e = e.firstChild; retorno e}) append (this)}} devuelva este, wrapInner:. función (e) {b.isFunction regreso ( e) this.each (function (t) {b (this) wrapInner (e.call (esto, t)).}):? this.each (function () {var t = b (este), n = t . contenidos (); n.length n.wrapAll (e):? t.append (e)})}, envoltura: función (e) {var t = b. isFunction (e); this.each regreso (function (n) {b (this) wrapAll (t e.call (este, n): e).?})}, desenvuelva: function () {return esto}, vacío: function () {var esto}, clon: function (e, t) {return e = null == e 1:?? e, t = null == t e: t, this.map (function () {return b.clone (esto , e, t)})}, html: function (e) {b.access regreso (this, function (e) {var n = esta [0] | | {}, r = 0, i = this.length; if (e === t) return 1 === n.nodeType n.innerHTML.replace (gt ","): ¡t; if (("string" = typeof t = b.isFunction (e);! devolución t | | "cadena" == typeof e | | (.. e = b (e) No (this) desconectar ()), this.domManip ([e], 0 , función (e) {var this.remove (e, 0!)}, domManip: function (e, n, r) = {e f.apply ([], e); var i, o, a, s, u, l, c = 0 , p = this.length, d = esto, h = p-1, g = e [0], m = b.isFunction (g); if (m | | (1> = p | | "cadena"! = typeof g | | b.support.checkClone) && Ct.test (g)) return this.each (function (i) {var esta}}); función de Lt (e, t) {return e.getElementsByTagName (t) [0] | | e.appendChild (e.ownerDocument.createElement (t))} la función Ht (e) {var t = e. getAttributeNode ("tipo"); regreso e.type = (t && t.specified) + "/" e.type, e} function + qt (e) {var t = Et.exec (e.type); regreso t e . type = t [1]: e.removeAttribute ("tipo"), e} función Mt (e, t) {var n, r = 0; for (; null = (n = e [r]); r + +! ) b._data (n, "globalEval", t | b._data (t [r] ", globalEval"! |) función)} _t (e, t) {if (1 === && t.nodeType b.hasData ( e)) {var n, r, i, o = b._data (e), a = b._data (t, o), s = o.events; if (s) {delete a.handle, a.events = {}; para (n en Ft (e, t) {var en this.pushStack (i)}}); función Ot (e, n) {var r, o, a = 0, s = typeof e.getElementsByTagName == i e.getElementsByTagName (n | | "*"):? typeof n === T | | n && b.nodeName (e, n) b.merge ([e] s): s} función Bt (e) {(e.type) && Nt.test (e.defaultChecked = e? . facturado) b.extend} ({clone: ​​function (e, t, n) {var _t (e, o); regreso
s = null, f}, CleanData: function (e, t) {var en a.events) f [r] b.event.remove (n, r):? b.removeEvent (n, r, a.handle), l [o] && (delete l [o], p delete n? ? [u]: typeof n.removeAttribute == i n.removeAttribute (u): n [u] = null, c.push (o))}}}); var tn (e, t) {if (t en e) return t;. var n = t.charAt (0) toUpperCase () + t.slice (1), r = t, i = en.length, mientras que (i -) si (t = es [i] + n, t en e) retu rn t; retorno r} función nn (e, t) {return e = T | | e, "ninguno" === b.css (e, "display") | | b.contains (e.ownerDocument, e)} la función rn (e, t) {var! e} b.fn.extend ({css: function (e, n) {b.access regreso (this, function (e, n, r) {var i, o, a = {}, s = 0; if ( b.isArray (n)) {for (o = Rt (e), i = n.length; i> s, 1 s + +) a [n [s]] = b.css (e, n [s],! , o);} devolver un retorno r == t b.style (e, n, r): b.css (e, n)}, e, n, arguments.length> 1)}, espectáculo: la función? () {return rn (esto, 0!)}, hide: function () {return rn (this)}, toggle: function (e) {var t = "booleano" == typeof e; regreso s && "conseguir" en s && (o = s.get (e, 1, i)!) == t o:? l [n]; if (a = typeof s && (r = s.set (e, r, i)) === t))) try {l [n] = r} catch (c) {}}}, css: function (e, n, r, i) {var o, a, s, u = b.camelCase (n); regreso n = b.cssProps [u] | | (b.cssProps [u] = tn (e.style, u)), s = b.cssHooks [n] | | b.cssHooks [u], s && "conseguir" en s && (a = s.get (e, 0, r)!), a === t && (a = peso (e, n , i)), "normal" === a && n en i, o, a = {}, por (o en t) a [o] = e.style [o], e.style [o] = t [o], i = n.apply (e, r | | []), por (o en t) e.style [o] = a [o]; vuelva i}}), e.getComputedStyle (Rt = function (t) {return e.getComputedStyle (t, null)}? , Peso = function (e, n, r) {var i, o, a, s = r | | Rt (e), u = s s.getPropertyValue (n) | | s [n]: t, l = e.style; regreso e.currentStyle}, Wt = function (e, n, r) {var i, o, a, s = r | | Rt (e), u = s s [n]: t, l = e.style; volver en (e, t, n) {var r = Vt.exec (t); r retorno Math.max (0, r [1] - (n | | 0)) + (r [2] | | "píxeles "): t} una función de (e, t, n, r, i) {var a} la función sn (e, t, n) {var i, r = a && (b.support.boxSizingReliable | | i === e.style [t]), i = parseFloat (i) | | 0} return i + an (e, t, n | | (a? "frontera": "contenido"), r, o) +} función "px" un (e) {var t = O, n = Gt [e]; regreso N | | (n = ln (e, t), !. "none" == n && n | | (Pt = (Pt | | b ("<iframe frameborder='0' width='0' height='0'/>") css ("cssText", "display: bloquear html> <body> <html> "), t.close (), n = ln (e, t), Pt.detach ()), Gt [e] = n), n} la función ln (e, t) {var n = b (t.createElement (e)) appendTo (t.body), r = b.css (n [0], "display"). n.remove return (), r} b.each ( ["altura", "ancho"], la función (e, n) {b.cssHooks [n] = {get: función (e, r, i) {return r 0 === e.offsetWidth && Xt.test (b . css (e, "display")) b.swap (e, Qt, function () {return sn (e, n, i)}): sn (e, n, i): t}, conjunto: la función (e, t, r) {var i = r && Rt (e), el retorno r = 0, i = {}, o = "string" == typeof n n.split (""): [n]; for (; 4> r, r + +) i [e + Zt [r] + t ] = o [r] | | o [r-2] | | o [0]; volver i}}, Ut.test (e) | | (. b.cssHooks [t + t] set = activado)}) ; var b.param (this.serializeArray ())}, serializeArray: function () {this.map regreso (function () {var e = b.prop (this, "elementos"), el retorno e b.makeArray (e) :. este}) filtro (function () {var e = this.type; regreso . n = b (this) val (); regreso para (r en e) gn (r, e [r], n, o);. regreso i.join ("&") sustituirá (cn, "+")}; función gn (e, t, n, r ) {var i; si (b.isArray (t)) b.each (t, la función (t, i) {N | | pn.test (e) r (e, i):? gn (e + "[" + ("objeto" == typeof i t: "!") + "]", i, n, r)}); else if (n | | "objeto" == b.type (t)) r ( e, t); más para (i en t) gn (e + "[" + i + "]", t [i], n, r)} b.each ("blur foco focusin focusOut redimensionar carga scroll descargar click DblClick mousedown mouseup mousemove mouseover mouseout MouseEnter MouseLeave cambio seleccione Enviar keydown pulsación keyup contextual error ". split (" "), la función (e, t) {b.fn [t] = function (e, n) {return arguments.length> 0? this.on (t, null, e, n):. this.trigger (t)}}), b.fn.hover = function (e, t) {return this.mouseenter (e) MouseLeave (t | | E )};?. [? &] var mn, yn, vn = b.now (), bn = / \ /, xn = / # * $ /, wn = / () = _ [^ &] * /, Tn = / ^ (*.?): [ Hn (e) {function regreso (t, n) {"string" = typeof t && (n = t, t = "*");! Var qn (e, n, r, i) {var o = {}, a = e === jn, función s (u) {var l;! devolución o [u] = 0, b.each (e [u ] | | [], la función (e, u) {var c = u (n, r, i);??! return "string" = typeof c | | A | | o [c] a (l = c ): t:! (n.dataTypes.unshift (c), s (c), 1)}), l} return s (n.dataTypes [0]) | | o ["*"] && s ("* ")} la función de Mn (e, n) {var r, i, o = b.ajaxSettings.flatOptions | | {};!? para (i n) n [i] == t && ((o [i] e : R | | (r = {})) [i] = n [i]); retorno r && b.extend (0, e, r), e} b.fn.load = function (e, n, r)! {if ("string" = typeof e Sn &&!) return Sn.apply (esto, argumentos); var i, o, a, s = este, u = e.indexOf (""); retorno u> = 0 && (i = ? e.slice (u, e.length), e = e.slice (0, u)), b.isFunction (n) (r = n, n = t): n && "objeto" == typeof this.on (t, e)}}), b.each (["get", "post"], la función (e, n) {b [n] = function (e, r, i, o) {return charset = UTF-8 ", acepta: {" * ": Dn, text:" text / plain ", html:" text / html ", xml:" application / xml, text / xml ", json:" application / json , text ": e.String," texto html ": 0," text json ": b.parseJSON," texto xml ": b.parseXML}, flatOptions: {url: 0, el contexto: 0}}, ajaxSetup : function (e, t) {return e && (n = e, e = t), n = n | | {}; var t, y si (2 === x) {if {c} = {(c!), mientras que (t = Tn.exec (a)) c [t [1] toLowerCase ().] t = [2]} t = c [e.toLowerCase ()]} return null == t nula: t}, getAllResponseHeaders: function () {return 2 === x R: null}, setRequestHeader: function (e, t) {var n = e.toLowerCase (); regreso x | | (e = v [n] = V [n] | | e, y [e] = t), esta}, overrideMimeType: función (e) {return x | | (p.mimeType = e), esto}, statusCode: function (e) {var t; if (e) if (2> x) por (t en e) m [t] = [m [t], e [ t]]; N.always demás (e [N.status]);} devolver este, abortar: function (e) {var t = e | | T; regreso && p.data (p.data = b.param (p.data, p.traditional)), qn (An, p, n, N), 2 === x) return "Dn + +"; q = 0,01 ":" "): p.accepts [" * "]), para (i en N.abort (); T = "abortar", porque (i C, k (-1, C)}} else k (-1, "No hay transporte"), la función k (e, n, r, i) {var N}, getScript: function (e, n) {return b.get (e, t, n, "script")}, getJSON: function (e, t, n) {return b.get (e, t, n , "json")}}); función _n (e, n, r) {var i, o, a, s, u = e.contents, l = e.dataTypes, c = e.responseFields, porque (en s c) s en en u) if (u [s] && u [s] prueba (o.)) {l.unshift (s); break} if (l [0] en r) a = l [0]; else {a (s en r) {if (l [0] | | e.converters [s + "" + l [0]]) {a = s;! romper} I | | (i = s)} a = a | | i} devolver un (a! == l [0] && l.unshift (a), R [A]):? t} función Fn (e, t) {var en "+ R] | | a [" * "! + R], i) para (n en a) si (o = n.split (" "), o [1] === r && (i = a [l + "" + o [0]] | | a ["* try {t = i (t)} catch (c) {return {estado: "ParserError", error: i c: "No la conversión de" + l + "a" + r}}} l = r} return {estado : "el éxito", los datos: t}} b.ajaxSetup ({acepta: {guión: "text / javascript, application / javascript, application / ECMAScript, application / x-ecmascript"}, contenidos: {guión :/ (?: java | ECMA) script /}, convertidores: {"text script": function (e) {return A = [], Bn = / (=) \ \ \ /; b.ajaxSetup ({jsonp? (= & | | $?):? "Devolución de llamada", jsonpCallback: function () {var e = On.pop () | | b.expando + "_" + vn + +;! devolver este [e] = 0, e}}), b.ajaxPrefilter ("json jsonp", la función (n, r, i) {var o, a, ¡s, u = n.jsonp == 1 && (Bn.test (n.url) "url": "string" == typeof json "] = function () {return s | | b.error (o +" no fue Pn, Rn, Wn = 0, $ n = e.ActiveXObject función && () {var correo, porque (e en Pn) Pn [e] (t, 0!)}; En función () {try {return new e.XMLHttpRequest } catch (t) {}} función zn () {try {return new ¡¡¡Rn, Rn = b.support.ajax = Rn, Rn && b.ajaxTransport (function (n) {if (n.crossDomain | | b.support.cors) {var r; regreso {enviar: function (i, o ) {var en en i) u.setRequestHeader (s, i [s])} catch (l) {} u.send (&& n.hasContent n.data | | null), r = function (e, i) {var s, l, c , p; try {if (r && (i | | 4 === u.readyState)) if (r = T, A && (u.onreadystatechange = b.noop, $ n && borrar i}]}; Kn function () {setTimeout regreso (function () {Xn = t}), Xn = b.now ()} la función Zn (e, t) {b.each (t, la función (t, n ) {var r = (Qn [t] | | []) concat (Qn ["*"]), i = 0, o = r.length;. for (; o> i, i + +) if (r [i ]. llamada (e, t, n)) return})} la función er (e, t, n) {var r, i, o = 0, a = Gn.length, s = b.Deferred (). Siempre ( function () {delete u.elem}), u = function () {if (i) return 1;! var r = b.Tween (e, l.opts, t, n, l.opts.specialEasing [t] | | l.opts.easing); l.tweens.push retorno (r), r}, parada: function ( t) {var n = 0, r = t l.tweens.length:?!. 0, si (i) devuélvalo esto; for (i = 0; r> n, n + +) l.tweens [n] run (1 ) volver r, el retorno tr (e, t) {var n, r, i, o, a; para (i en e) if (r = b.camelCase (i), o = t [r], n = e [i], b IsArray. && (n) (o = n [1], n = e [i] = n [0]), i! == r && (e [r] = n, borrar e [i]), a = b . cssHooks [r], a && "ampliar" en a) {n = a.expand (n), delete e [r], porque (i n) i en e | | (e [i] = n [i] , t [i] = o)} else t [r] = o} b.Animation = b.extend (er, {tweener: function (e, t) {b.isFunction (e) (t = e, e = ["*"]): e = e.split (""); var nr (e, t, n) {var t | | "width" en en t) if (a = t [i], Vn.exec (a)) {if (delete ¿s && (m = s.hidden), && u (! s.hidden = m), m b (e) show ():. f.done (function () {b (e) hide ().}), f . hacer (function () {var t; b._removeData (e, "fxshow"), porque (en t h) b.style (e, t, h [t])}); for (i = 0; o > i, i + +) r = g [i], l = f.createTween (r, m s [r]: 0), h [r] = s [r] | | b.style (e, r), r en s | | (s [r] = l.start, m && (l.end = l.start, l.start = "width" === R | |? "altura" === r 1:0) retorno)}} función rr (e, t, n, r, i) {nueva ¿e = rr.propHooks [this.prop]; retorno e && e.get e.get (este): rr.propHooks._default.get (this)}, plazo: function (e) {var t, n = rr.propHooks [this.prop], volverá t; regreso n = b.fn [t]; b.fn [t] = function (e, r, i) {return null == e | | "booleano" == typeof i = b.isEmptyObject (e), o = b.speed (t, n, r), una función = () {var ? a.finish = a, i | | o.queue === 1 this.each (a): this.queue (o.queue, a)}, parada: function (e, n, r) {var i = function (e) {var t = e.stop; delete e.stop, t (r)};! return "string" = typeof e && (r = n, n = e, e = t), n && e ==! ! 1 && this.queue (e | | "fx", []), this.each (function () {var t = 0, n = null && e = e + "queueHooks", o = b.timers, a = b ¡. _data (this);. if (n) a [n] && a [n] detener && i (a [n]); más para (n en e == 1 && (e = e | | "fx")!!, this.each (function () {var n.finish})}}); función de ir (e, t) {var n, r = {height: e}, i = 0; para (t = t 1:00; 4> i, i + = 2 - t) n = Zt [i], r ["margen" + n] = r ["relleno" + n] = e; regreso this.animate (t, e, n, r)}}), b.speed "objeto" = function (e, t, n) {var r = e && == typeof ¿r.duration b.fx.off = 0: "number" == typeof r.duration r.duration: r.duration en b.grep (b.timers, función (t) {return e === t.elem}). longitud}), b.fn.offset = function (e) {if return (arguments.length) e === t esto: this.each (function (t) {b.offset.setOffset (esto, e, t)}); var n, r, o = {top: 0, izquierda: 0}?, a = esta [0 ], s = a && a.ownerDocument; if (s) return n = s.documentElement, b.contains (n, a) (typeof? r = b.css (e, "posición"); === r && "estáticos" (e.style.position = "relativa"); var t t.using.call (e, l):? i.css (l)}}, b.fn.extend ({position: function () {if (esto [0]) {var (función this.map () {var r = / Y / .test (n); b.fn [e] = function (i) {b.access regreso (this, function (e, i, o) {var a = o (e), el retorno o = == t? un? n en o (e) {return a = && arguments.length (r | | "booleano" = typeof i!), s = r | | (i === 0 | | o === 0 "margen": "frontera"!?); regreso b . acceso (esto, la función (n, r, i) {var o; regreso definir && && define.amd && define.amd.jQuery define ("jquery", [], function () {return b})}) (window);